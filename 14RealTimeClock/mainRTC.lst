CCS PCM C Compiler, Version 5.015, 5967               11-out-22 03:53

               Filename:   C:\Users\Sadla\OneDrive\Documentos\MEGAsync\doc\Facul\Microcontroladores\Projetos\14RealTimeClock\mainRTC.lst

               ROM used:   854 words (10%)
                           Largest free fragment is 2048
               RAM used:   32 (9%) at main() level
                           45 (12%) worst case
               Stack used: 4 locations
               Stack size: 8

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   2DC
0003:  NOP
.................... /* 
.................... SDA = PIN_C4; 
.................... SCL = PIN_C3; 
.................... */ 
....................  
.................... //#include <mainRTC.h> 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  28
0009:  RETLW  0F
000A:  RETLW  01
000B:  RETLW  06
000C:  DATA 8C,24
000D:  DATA EE,34
000E:  DATA E3,34
000F:  DATA 61,37
0010:  DATA E4,37
0011:  DATA 2E,17
0012:  DATA 2E,00
0013:  DATA 0C,2A
0014:  DATA C9,26
0015:  DATA 45,1D
0016:  DATA A0,12
0017:  DATA 30,19
0018:  DATA 75,1D
0019:  DATA 25,18
001A:  DATA B2,3A
001B:  DATA BA,12
001C:  DATA 30,19
001D:  DATA 75,00
*
00EE:  MOVF   0B,W
00EF:  MOVWF  38
00F0:  BCF    0B.7
00F1:  BSF    03.5
00F2:  BSF    03.6
00F3:  BSF    0C.7
00F4:  BSF    0C.0
00F5:  NOP
00F6:  NOP
00F7:  BCF    03.5
00F8:  BCF    03.6
00F9:  BTFSC  38.7
00FA:  BSF    0B.7
00FB:  BSF    03.6
00FC:  MOVF   0C,W
00FD:  ANDLW  7F
00FE:  BTFSC  03.2
00FF:  GOTO   142
0100:  BCF    03.6
0101:  MOVWF  38
0102:  BSF    03.6
0103:  MOVF   0D,W
0104:  BCF    03.6
0105:  MOVWF  39
0106:  BSF    03.6
0107:  MOVF   0F,W
0108:  BCF    03.6
0109:  MOVWF  3A
010A:  MOVF   38,W
010B:  MOVWF  3F
010C:  CALL   0B7
010D:  MOVF   39,W
010E:  BSF    03.6
010F:  MOVWF  0D
0110:  BCF    03.6
0111:  MOVF   3A,W
0112:  BSF    03.6
0113:  MOVWF  0F
0114:  BCF    03.6
0115:  MOVF   0B,W
0116:  MOVWF  3B
0117:  BCF    0B.7
0118:  BSF    03.5
0119:  BSF    03.6
011A:  BSF    0C.7
011B:  BSF    0C.0
011C:  NOP
011D:  NOP
011E:  BCF    03.5
011F:  BCF    03.6
0120:  BTFSC  3B.7
0121:  BSF    0B.7
0122:  BSF    03.6
0123:  RLF    0C,W
0124:  RLF    0E,W
0125:  ANDLW  7F
0126:  BTFSC  03.2
0127:  GOTO   142
0128:  BCF    03.6
0129:  MOVWF  38
012A:  BSF    03.6
012B:  MOVF   0D,W
012C:  BCF    03.6
012D:  MOVWF  39
012E:  BSF    03.6
012F:  MOVF   0F,W
0130:  BCF    03.6
0131:  MOVWF  3A
0132:  MOVF   38,W
0133:  MOVWF  3F
0134:  CALL   0B7
0135:  MOVF   39,W
0136:  BSF    03.6
0137:  MOVWF  0D
0138:  BCF    03.6
0139:  MOVF   3A,W
013A:  BSF    03.6
013B:  MOVWF  0F
013C:  INCF   0D,F
013D:  BTFSC  03.2
013E:  INCF   0F,F
013F:  BCF    03.6
0140:  GOTO   0EE
0141:  BSF    03.6
0142:  BCF    03.6
0143:  BCF    0A.3
0144:  BCF    0A.4
0145:  GOTO   308 (RETURN)
*
01B0:  CLRF   77
01B1:  CLRF   78
01B2:  MOVF   3B,W
01B3:  BCF    03.0
01B4:  BTFSC  3C.0
01B5:  ADDWF  77,F
01B6:  RRF    77,F
01B7:  RRF    78,F
01B8:  BTFSC  3C.1
01B9:  ADDWF  77,F
01BA:  RRF    77,F
01BB:  RRF    78,F
01BC:  BTFSC  3C.2
01BD:  ADDWF  77,F
01BE:  RRF    77,F
01BF:  RRF    78,F
01C0:  BTFSC  3C.3
01C1:  ADDWF  77,F
01C2:  RRF    77,F
01C3:  RRF    78,F
01C4:  BTFSC  3C.4
01C5:  ADDWF  77,F
01C6:  RRF    77,F
01C7:  RRF    78,F
01C8:  BTFSC  3C.5
01C9:  ADDWF  77,F
01CA:  RRF    77,F
01CB:  RRF    78,F
01CC:  BTFSC  3C.6
01CD:  ADDWF  77,F
01CE:  RRF    77,F
01CF:  RRF    78,F
01D0:  BTFSC  3C.7
01D1:  ADDWF  77,F
01D2:  RRF    77,F
01D3:  RRF    78,F
*
0239:  MOVF   0B,W
023A:  MOVWF  3C
023B:  BCF    0B.7
023C:  BSF    03.5
023D:  BSF    03.6
023E:  BSF    0C.7
023F:  BSF    0C.0
0240:  NOP
0241:  NOP
0242:  BCF    03.5
0243:  BCF    03.6
0244:  BTFSC  3C.7
0245:  BSF    0B.7
0246:  BTFSC  03.0
0247:  GOTO   270
0248:  BSF    03.6
0249:  MOVF   0C,W
024A:  ANDLW  7F
024B:  BCF    03.6
024C:  MOVWF  3C
024D:  BSF    03.6
024E:  MOVF   0D,W
024F:  BCF    03.6
0250:  MOVWF  3D
0251:  BSF    03.6
0252:  MOVF   0F,W
0253:  BCF    03.6
0254:  MOVWF  3E
0255:  MOVF   3C,W
0256:  MOVWF  3F
0257:  CALL   0B7
0258:  MOVF   3D,W
0259:  BSF    03.6
025A:  MOVWF  0D
025B:  BCF    03.6
025C:  MOVF   3E,W
025D:  BSF    03.6
025E:  MOVWF  0F
025F:  BCF    03.6
0260:  MOVF   0B,W
0261:  MOVWF  3F
0262:  BCF    0B.7
0263:  BSF    03.5
0264:  BSF    03.6
0265:  BSF    0C.7
0266:  BSF    0C.0
0267:  NOP
0268:  NOP
0269:  BCF    03.5
026A:  BCF    03.6
026B:  BTFSC  3F.7
026C:  BSF    0B.7
026D:  DECFSZ 3B,F
026E:  GOTO   270
026F:  GOTO   28F
0270:  BSF    03.6
0271:  RLF    0C,W
0272:  RLF    0E,W
0273:  ANDLW  7F
0274:  BCF    03.6
0275:  MOVWF  3C
0276:  BSF    03.6
0277:  MOVF   0D,W
0278:  BCF    03.6
0279:  MOVWF  3D
027A:  BSF    03.6
027B:  MOVF   0F,W
027C:  BCF    03.6
027D:  MOVWF  3E
027E:  MOVF   3C,W
027F:  MOVWF  3F
0280:  CALL   0B7
0281:  MOVF   3D,W
0282:  BSF    03.6
0283:  MOVWF  0D
0284:  BCF    03.6
0285:  MOVF   3E,W
0286:  BSF    03.6
0287:  MOVWF  0F
0288:  INCF   0D,F
0289:  BTFSC  03.2
028A:  INCF   0F,F
028B:  BCF    03.0
028C:  BCF    03.6
028D:  DECFSZ 3B,F
028E:  GOTO   239
028F:  BCF    0A.3
0290:  BCF    0A.4
0291:  GOTO   338 (RETURN)
0292:  MOVF   3E,W
0293:  CLRF   78
0294:  SUBWF  3D,W
0295:  BTFSC  03.0
0296:  GOTO   29A
0297:  MOVF   3D,W
0298:  MOVWF  77
0299:  GOTO   2A6
029A:  CLRF   77
029B:  MOVLW  08
029C:  MOVWF  3F
029D:  RLF    3D,F
029E:  RLF    77,F
029F:  MOVF   3E,W
02A0:  SUBWF  77,W
02A1:  BTFSC  03.0
02A2:  MOVWF  77
02A3:  RLF    78,F
02A4:  DECFSZ 3F,F
02A5:  GOTO   29D
02A6:  RETURN
02A7:  MOVF   78,W
02A8:  MOVF   3B,W
02A9:  MOVWF  3D
02AA:  MOVLW  64
02AB:  MOVWF  3E
02AC:  CALL   292
02AD:  MOVF   77,W
02AE:  MOVWF  3B
02AF:  MOVF   78,W
02B0:  MOVLW  30
02B1:  BTFSS  03.2
02B2:  GOTO   2BA
02B3:  BTFSS  3C.1
02B4:  GOTO   2C1
02B5:  BTFSC  3C.3
02B6:  GOTO   2C1
02B7:  BTFSC  3C.4
02B8:  MOVLW  20
02B9:  GOTO   2BD
02BA:  BCF    3C.3
02BB:  BCF    3C.4
02BC:  BSF    3C.0
02BD:  ADDWF  78,F
02BE:  MOVF   78,W
02BF:  MOVWF  3F
02C0:  CALL   0B7
02C1:  MOVF   3B,W
02C2:  MOVWF  3D
02C3:  MOVLW  0A
02C4:  MOVWF  3E
02C5:  CALL   292
02C6:  MOVF   77,W
02C7:  MOVWF  3B
02C8:  MOVF   78,W
02C9:  MOVLW  30
02CA:  BTFSS  03.2
02CB:  GOTO   2D2
02CC:  BTFSC  3C.3
02CD:  GOTO   2D6
02CE:  BTFSS  3C.0
02CF:  GOTO   2D6
02D0:  BTFSC  3C.4
02D1:  MOVLW  20
02D2:  ADDWF  78,F
02D3:  MOVF   78,W
02D4:  MOVWF  3F
02D5:  CALL   0B7
02D6:  MOVLW  30
02D7:  ADDWF  3B,F
02D8:  MOVF   3B,W
02D9:  MOVWF  3F
02DA:  CALL   0B7
02DB:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC=10 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20000000) 
*
001E:  MOVLW  40
001F:  MOVWF  04
0020:  BCF    03.7
0021:  MOVF   00,W
0022:  BTFSC  03.2
0023:  GOTO   031
0024:  MOVLW  06
0025:  MOVWF  78
0026:  CLRF   77
0027:  DECFSZ 77,F
0028:  GOTO   027
0029:  DECFSZ 78,F
002A:  GOTO   026
002B:  MOVLW  7B
002C:  MOVWF  77
002D:  DECFSZ 77,F
002E:  GOTO   02D
002F:  DECFSZ 00,F
0030:  GOTO   024
0031:  RETURN
....................  
.................... //comunicacao pelo protocolo I2C 
.................... #use I2C(MASTER, I2C1, SLOW = 100000, STREAM = DS3231_STREAM) 
*
0146:  BCF    14.7
0147:  BCF    0C.3
0148:  MOVF   3C,W
0149:  MOVWF  13
014A:  MOVLW  02
014B:  BTFSC  14.7
014C:  GOTO   154
014D:  BTFSS  0C.3
014E:  GOTO   14D
014F:  MOVLW  00
0150:  BSF    03.5
0151:  BTFSC  11.6
0152:  MOVLW  01
0153:  BCF    03.5
0154:  MOVWF  78
0155:  RETURN
0156:  BCF    14.6
0157:  BSF    03.5
0158:  BSF    11.3
0159:  BTFSC  11.3
015A:  GOTO   159
015B:  BTFSC  77.0
015C:  BCF    11.5
015D:  BTFSS  77.0
015E:  BSF    11.5
015F:  BSF    11.4
0160:  BTFSC  11.4
0161:  GOTO   160
0162:  BCF    03.5
0163:  MOVF   13,W
0164:  MOVWF  78
0165:  RETURN
....................  
.................... //Esquema dos pinos do LCD 
.................... #ifndef lcd_enable 
....................    #define lcd_enable pin_E1 // pino enable do LCD 
....................    #define lcd_rs pin_E2 // pino rs do LCD 
....................    //#define lcd_rw pin_e2 // pino rw do LCD 
....................    #define lcd_d4 pin_d4 // pino de dados d4 do LCD 
....................    #define lcd_d5 pin_d5 // pino de dados d5 do LCD 
....................    #define lcd_d6 pin_d6 // pino de dados d6 do LCD 
....................    #define lcd_d7 pin_d7 // pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #include <mod_lcd.c> 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipulação de módulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: Fábio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // As definições a seguir são utilizadas para acesso aos pinos do display 
.................... // caso o pino RW não seja utilizado, comente a definição lcd_rw 
.................... #ifndef lcd_enable 
.................... 	#define lcd_enable 		pin_e1		// pino enable do LCD 
.................... 	#define lcd_rs			pin_e0		// pino rs do LCD 
.................... 	//#define lcd_rw		pin_e2		// pino rw do LCD 
.................... 	#define lcd_d4			pin_d4		// pino de dados d4 do LCD 
.................... 	#define lcd_d5			pin_d5		// pino de dados d5 do LCD 
.................... 	#define lcd_d6			pin_d6		// pino de dados d6 do LCD 
.................... 	#define lcd_d7			pin_d7		// pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endereço da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seqüência de inicialização do módulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... byte lcd_le_byte() 
.................... // lê um byte do LCD (somente com pino RW) 
.................... { 
.................... 	byte dado; 
.................... 	// configura os pinos de dados como entradas 
.................... 	input(lcd_d4); 
.................... 	input(lcd_d5); 
.................... 	input(lcd_d6); 
.................... 	input(lcd_d7); 
.................... 	// se o pino rw for utilizado, coloca em 1 
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
....................    output_high(lcd_enable); // habilita display 
.................... 	dado = 0;	// zera a variável de leitura 
.................... 	// lê os quatro bits mais significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,7); 
.................... 	if (input(lcd_d6)) bit_set(dado,6); 
.................... 	if (input(lcd_d5)) bit_set(dado,5); 
.................... 	if (input(lcd_d4)) bit_set(dado,4); 
.................... 	// dá um pulso na linha enable 
.................... 	output_low(lcd_enable); 
.................... 	output_high(lcd_enable); 
.................... 	// lê os quatro bits menos significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,3); 
.................... 	if (input(lcd_d6)) bit_set(dado,2); 
.................... 	if (input(lcd_d5)) bit_set(dado,1); 
.................... 	if (input(lcd_d4)) bit_set(dado,0); 
.................... 	output_low(lcd_enable);	// desabilita o display 
.................... 	return dado;	// retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
.................... 	// coloca os quatro bits nas saidas 
.................... 	output_bit(lcd_d4,bit_test(dado,0)); 
*
0032:  BTFSC  47.0
0033:  GOTO   036
0034:  BCF    08.4
0035:  GOTO   037
0036:  BSF    08.4
0037:  BSF    03.5
0038:  BCF    08.4
.................... 	output_bit(lcd_d5,bit_test(dado,1)); 
0039:  BCF    03.5
003A:  BTFSC  47.1
003B:  GOTO   03E
003C:  BCF    08.5
003D:  GOTO   03F
003E:  BSF    08.5
003F:  BSF    03.5
0040:  BCF    08.5
.................... 	output_bit(lcd_d6,bit_test(dado,2)); 
0041:  BCF    03.5
0042:  BTFSC  47.2
0043:  GOTO   046
0044:  BCF    08.6
0045:  GOTO   047
0046:  BSF    08.6
0047:  BSF    03.5
0048:  BCF    08.6
.................... 	output_bit(lcd_d7,bit_test(dado,3)); 
0049:  BCF    03.5
004A:  BTFSC  47.3
004B:  GOTO   04E
004C:  BCF    08.7
004D:  GOTO   04F
004E:  BSF    08.7
004F:  BSF    03.5
0050:  BCF    08.7
.................... 	// dá um pulso na linha enable 
.................... 	output_high(lcd_enable); 
0051:  BCF    09.1
0052:  BCF    03.5
0053:  BSF    09.1
.................... 	output_low(lcd_enable); 
0054:  BSF    03.5
0055:  BCF    09.1
0056:  BCF    03.5
0057:  BCF    09.1
0058:  RETURN
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
.................... 	// coloca a linha rs em 0 
.................... 	output_low(lcd_rs); 
0059:  BSF    03.5
005A:  BCF    09.2
005B:  BCF    03.5
005C:  BCF    09.2
.................... 	// aguarda o display ficar desocupado 
.................... 	//while ( bit_test(lcd_le_byte(),7) ) ; 
.................... 	// configura a linha rs dependendo do modo selecionado 
.................... 	output_bit(lcd_rs,endereco); 
005D:  MOVF   44,F
005E:  BTFSS  03.2
005F:  GOTO   062
0060:  BCF    09.2
0061:  GOTO   063
0062:  BSF    09.2
0063:  BSF    03.5
0064:  BCF    09.2
.................... 	delay_us(100);	// aguarda 100 us 
0065:  MOVLW  A6
0066:  MOVWF  77
0067:  DECFSZ 77,F
0068:  GOTO   067
0069:  NOP
.................... 	// caso a linha rw esteja definida, coloca em 0 
.................... 	#ifdef lcd_rw 
.................... 		output_low(lcd_rw); 
.................... 	#endif 
.................... 	// desativa linha enable 
.................... 	output_low(lcd_enable); 
006A:  BCF    09.1
006B:  BCF    03.5
006C:  BCF    09.1
.................... 	// envia a primeira parte do byte 
.................... 	lcd_envia_nibble(dado >> 4); 
006D:  SWAPF  45,W
006E:  MOVWF  46
006F:  MOVLW  0F
0070:  ANDWF  46,F
0071:  MOVF   46,W
0072:  MOVWF  47
0073:  CALL   032
.................... 	// envia a segunda parte do byte 
.................... 	lcd_envia_nibble(dado & 0x0f); 
0074:  MOVF   45,W
0075:  ANDLW  0F
0076:  MOVWF  46
0077:  MOVWF  47
0078:  CALL   032
0079:  RETURN
.................... } 
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicialização do display 
.................... { 
.................... 	byte conta; 
.................... 	output_low(lcd_d4); 
007A:  BSF    03.5
007B:  BCF    08.4
007C:  BCF    03.5
007D:  BCF    08.4
.................... 	output_low(lcd_d5); 
007E:  BSF    03.5
007F:  BCF    08.5
0080:  BCF    03.5
0081:  BCF    08.5
.................... 	output_low(lcd_d6); 
0082:  BSF    03.5
0083:  BCF    08.6
0084:  BCF    03.5
0085:  BCF    08.6
.................... 	output_low(lcd_d7); 
0086:  BSF    03.5
0087:  BCF    08.7
0088:  BCF    03.5
0089:  BCF    08.7
.................... 	output_low(lcd_rs); 
008A:  BSF    03.5
008B:  BCF    09.2
008C:  BCF    03.5
008D:  BCF    09.2
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
.................... 	output_low(lcd_enable); 
008E:  BSF    03.5
008F:  BCF    09.1
0090:  BCF    03.5
0091:  BCF    09.1
.................... 	delay_ms(15); 
0092:  MOVLW  0F
0093:  MOVWF  40
0094:  CALL   01E
.................... 	// envia uma seqüência de 3 vezes 0x03 
.................... 	// e depois 0x02 para configurar o módulo 
.................... 	// para modo de 4 bits 
.................... 	for(conta=1;conta<=3;++conta) 
0095:  MOVLW  01
0096:  MOVWF  38
0097:  MOVF   38,W
0098:  SUBLW  03
0099:  BTFSS  03.0
009A:  GOTO   0A3
.................... 	{ 
.................... 		lcd_envia_nibble(3); 
009B:  MOVLW  03
009C:  MOVWF  47
009D:  CALL   032
.................... 		delay_ms(5); 
009E:  MOVLW  05
009F:  MOVWF  40
00A0:  CALL   01E
00A1:  INCF   38,F
00A2:  GOTO   097
.................... 	} 
.................... 	lcd_envia_nibble(2); 
00A3:  MOVLW  02
00A4:  MOVWF  47
00A5:  CALL   032
.................... 	// envia string de inicialização do display 
.................... 	for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
00A6:  CLRF   38
00A7:  MOVF   38,W
00A8:  SUBLW  03
00A9:  BTFSS  03.0
00AA:  GOTO   0B4
00AB:  MOVF   38,W
00AC:  CALL   004
00AD:  MOVWF  39
00AE:  CLRF   44
00AF:  MOVF   39,W
00B0:  MOVWF  45
00B1:  CALL   059
00B2:  INCF   38,F
00B3:  GOTO   0A7
00B4:  BCF    0A.3
00B5:  BCF    0A.4
00B6:  GOTO   2FE (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
00D1:  DECFSZ 41,W
00D2:  GOTO   0D4
00D3:  GOTO   0D7
....................    	endereco = lcd_seg_lin; 
00D4:  MOVLW  40
00D5:  MOVWF  42
00D6:  GOTO   0D8
....................    else 
....................    	endereco = 0; 
00D7:  CLRF   42
....................    endereco += x-1; 
00D8:  MOVLW  01
00D9:  SUBWF  40,W
00DA:  ADDWF  42,F
....................    lcd_envia_byte(0,0x80|endereco); 
00DB:  MOVF   42,W
00DC:  IORLW  80
00DD:  MOVWF  43
00DE:  CLRF   44
00DF:  MOVF   43,W
00E0:  MOVWF  45
00E1:  CALL   059
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
*
00B7:  MOVF   3F,W
00B8:  XORLW  0C
00B9:  BTFSC  03.2
00BA:  GOTO   0C5
00BB:  XORLW  06
00BC:  BTFSC  03.2
00BD:  GOTO   0CD
00BE:  XORLW  07
00BF:  BTFSC  03.2
00C0:  GOTO   0CD
00C1:  XORLW  05
00C2:  BTFSC  03.2
00C3:  GOTO   0E3
00C4:  GOTO   0E8
.................... 	{ 
....................      case '\f' 	:	lcd_envia_byte(0,1); 
00C5:  CLRF   44
00C6:  MOVLW  01
00C7:  MOVWF  45
00C8:  CALL   059
.................... 	  			delay_ms(2); 
00C9:  MOVLW  02
00CA:  MOVWF  40
00CB:  CALL   01E
.................... 				break; 
00CC:  GOTO   0ED
....................      case '\n'	: 
.................... 	  case '\r' 	:	lcd_pos_xy(1,2); 
00CD:  MOVLW  01
00CE:  MOVWF  40
00CF:  MOVLW  02
00D0:  MOVWF  41
.................... 	  			break; 
*
00E2:  GOTO   0ED
....................      case '\b' 	:	lcd_envia_byte(0,0x10); 
00E3:  CLRF   44
00E4:  MOVLW  10
00E5:  MOVWF  45
00E6:  CALL   059
.................... 	  			break; 
00E7:  GOTO   0ED
....................      default	:	lcd_envia_byte(1,c); 
00E8:  MOVLW  01
00E9:  MOVWF  44
00EA:  MOVF   3F,W
00EB:  MOVWF  45
00EC:  CALL   059
.................... 	  			break; 
....................    } 
00ED:  RETURN
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
.................... 	char valor; 
.................... 	// seleciona a posição do caractere 
.................... 	lcd_pos_xy(x,y); 
.................... 	// ativa rs 
.................... 	output_high(lcd_rs); 
.................... 	// lê o caractere 
.................... 	valor = lcd_le_byte(); 
.................... 	// desativa rs 
.................... 	output_low(lcd_rs); 
.................... 	// retorna o valor do caractere 
.................... 	return valor; 
.................... } 
....................  
.................... #include "DS3231.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                             DS3231.c                              //// 
.................... ////                                                                   //// 
.................... ////                      Driver for CCS C compiler                    //// 
.................... ////                                                                   //// 
.................... ////     Driver for Maxim DS3231 serial I2C real-time clock (RTC).     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                     https://simple-circuit.com/                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #if defined DS3231_I2C_NO_STREAM 
....................   #define RTC_I2C_START()   i2c_start() 
....................   #define RTC_I2C_STOP()    i2c_stop() 
....................   #define RTC_I2C_WRITE(x)  i2c_write(x) 
....................   #define RTC_I2C_READ(x)   i2c_read(x) 
.................... #elif defined DS3231_I2C_STREAM 
....................   #define RTC_I2C_START()   i2c_start(DS3231_I2C_STREAM) 
....................   #define RTC_I2C_STOP()    i2c_stop(DS3231_I2C_STREAM) 
....................   #define RTC_I2C_WRITE(x)  i2c_write(DS3231_I2C_STREAM, x) 
....................   #define RTC_I2C_READ(x)   i2c_read(DS3231_I2C_STREAM, x) 
.................... #else 
....................   #define RTC_I2C_START()   i2c_start(DS3231_STREAM) 
....................   #define RTC_I2C_STOP()    i2c_stop(DS3231_STREAM) 
....................   #define RTC_I2C_WRITE(x)  i2c_write(DS3231_STREAM, x) 
....................   #define RTC_I2C_READ(x)   i2c_read(DS3231_STREAM, x) 
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define DS3231_ADDRESS       0xD0 
.................... #define DS3231_REG_SECONDS   0x00 
.................... #define DS3231_REG_AL1_SEC   0x07 
.................... #define DS3231_REG_AL2_MIN   0x0B 
.................... #define DS3231_REG_CONTROL   0x0E 
.................... #define DS3231_REG_STATUS    0x0F 
.................... #define DS3231_REG_TEMP_MSB  0x11 
....................  
.................... typedef enum 
.................... { 
....................   SUNDAY = 1, 
....................   MONDAY, 
....................   TUESDAY, 
....................   WEDNESDAY, 
....................   THURSDAY, 
....................   FRIDAY, 
....................   SATURDAY 
.................... } RTC_DOW; 
....................  
.................... typedef enum 
.................... { 
....................   JANUARY = 1, 
....................   FEBRUARY, 
....................   MARCH, 
....................   APRIL, 
....................   MAY, 
....................   JUNE, 
....................   JULY, 
....................   AUGUST, 
....................   SEPTEMBER, 
....................   OCTOBER, 
....................   NOVEMBER, 
....................   DECEMBER 
.................... } RTC_Month; 
....................  
.................... typedef struct rtc_tm 
.................... { 
....................   uint8_t seconds; 
....................   uint8_t minutes; 
....................   uint8_t hours; 
....................   RTC_DOW dow; 
....................   uint8_t day; 
....................   RTC_Month month; 
....................   uint8_t year; 
.................... } RTC_Time; 
....................  
.................... typedef enum 
.................... { 
....................   ONCE_PER_SECOND = 0x0F, 
....................   SECONDS_MATCH = 0x0E, 
....................   MINUTES_SECONDS_MATCH = 0x0C, 
....................   HOURS_MINUTES_SECONDS_MATCH = 0x08, 
....................   DATE_HOURS_MINUTES_SECONDS_MATCH = 0x0, 
....................   DAY_HOURS_MINUTES_SECONDS_MATCH = 0x10 
.................... } al1; 
....................  
.................... typedef enum 
.................... { 
....................   ONCE_PER_MINUTE = 0x0E, 
....................   MINUTES_MATCH = 0x0C, 
....................   HOURS_MINUTES_MATCH = 0x08, 
....................   DATE_HOURS_MINUTES_MATCH = 0x0, 
....................   DAY_HOURS_MINUTES_MATCH = 0x10 
.................... } al2; 
....................  
.................... typedef enum 
.................... { 
....................   OUT_OFF = 0x00, 
....................   OUT_INT = 0x04, 
....................   OUT_1Hz = 0x40, 
....................   OUT_1024Hz = 0x48, 
....................   OUT_4096Hz = 0x50, 
....................   OUT_8192Hz = 0x58 
.................... } INT_SQW; 
....................  
.................... RTC_Time c_time, c_alarm1, c_alarm2; 
....................  
.................... ///////////////////////// All Functions ///////////////////////// 
....................                                                                // 
.................... uint8_t bcd_to_decimal(uint8_t number);                        // 
.................... uint8_t decimal_to_bcd(uint8_t number);                        // 
.................... void RTC_Set(RTC_Time *time_t);                                // 
.................... RTC_Time *RTC_Get();                                           // 
.................... void Alarm1_Set(RTC_Time *time_t, al1 _config);                // 
.................... RTC_Time *Alarm1_Get();                                        // 
.................... void Alarm1_Enable();                                          // 
.................... void Alarm1_Disable();                                         // 
.................... int1 Alarm1_IF_Check();                                        // 
.................... void Alarm1_IF_Reset();                                        // 
.................... int1 Alarm1_Status();                                          // 
.................... void Alarm2_Set(RTC_Time *time_t, al2 _config);                // 
.................... RTC_Time *Alarm2_Get();                                        // 
.................... void Alarm2_Enable();                                          // 
.................... void Alarm2_Disable();                                         // 
.................... int1 Alarm2_IF_Check();                                        // 
.................... void Alarm2_IF_Reset();                                        // 
.................... int1 Alarm2_Status();                                          // 
.................... void IntSqw_Set(INT_SQW _config);                              // 
.................... void Enable_32kHZ();                                           // 
.................... void Disable_32kHZ();                                          // 
.................... void OSC_Start();                                              // 
.................... void OSC_Stop();                                               // 
.................... int16_t Get_Temperature();                                     // 
.................... uint8_t RTC_Read_Reg(uint8_t reg_address);                     // 
.................... void RTC_Write_Reg(uint8_t reg_address, uint8_t reg_value);    // 
....................                                                                // 
.................... ///////////////////////////////////////////////////////////////// 
....................  
.................... // converts BCD to decimal 
.................... uint8_t bcd_to_decimal(uint8_t number) 
.................... { 
....................   return ( (number >> 4) * 10 + (number & 0x0F) ); 
*
01A6:  SWAPF  38,W
01A7:  MOVWF  77
01A8:  MOVLW  0F
01A9:  ANDWF  77,F
01AA:  MOVF   77,W
01AB:  MOVWF  3A
01AC:  MOVF   3A,W
01AD:  MOVWF  3B
01AE:  MOVLW  0A
01AF:  MOVWF  3C
*
01D4:  MOVF   78,W
01D5:  MOVWF  39
01D6:  MOVF   38,W
01D7:  ANDLW  0F
01D8:  ADDWF  78,W
01D9:  MOVWF  78
01DA:  RETURN
.................... } 
....................  
.................... // converts decimal to BCD 
.................... uint8_t decimal_to_bcd(uint8_t number) 
.................... { 
....................   return ( ((number / 10) << 4) + (number % 10) ); 
.................... } 
....................  
.................... // sets time and date 
.................... void RTC_Set(RTC_Time *time_t) 
.................... { 
....................   // convert decimal to BCD 
....................   time_t->day     = decimal_to_bcd(time_t->day); 
....................   time_t->month   = decimal_to_bcd(time_t->month); 
....................   time_t->year    = decimal_to_bcd(time_t->year); 
....................   time_t->hours   = decimal_to_bcd(time_t->hours); 
....................   time_t->minutes = decimal_to_bcd(time_t->minutes); 
....................   time_t->seconds = decimal_to_bcd(time_t->seconds); 
....................   // end conversion 
....................  
....................   // write data to the RTC chip 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS3231_ADDRESS); 
....................   RTC_I2C_WRITE(DS3231_REG_SECONDS); 
....................   RTC_I2C_WRITE(time_t->seconds); 
....................   RTC_I2C_WRITE(time_t->minutes); 
....................   RTC_I2C_WRITE(time_t->hours); 
....................   RTC_I2C_WRITE(time_t->dow); 
....................   RTC_I2C_WRITE(time_t->day); 
....................   RTC_I2C_WRITE(time_t->month); 
....................   RTC_I2C_WRITE(time_t->year); 
....................   RTC_I2C_STOP(); 
.................... } 
....................  
.................... // reads time and date 
.................... RTC_Time *RTC_Get() 
.................... { 
....................   RTC_I2C_START(); 
01DB:  BSF    03.5
01DC:  BSF    11.0
01DD:  BTFSC  11.0
01DE:  GOTO   1DD
....................   RTC_I2C_WRITE(DS3231_ADDRESS); 
01DF:  MOVLW  D0
01E0:  BCF    03.5
01E1:  MOVWF  3C
01E2:  CALL   146
....................   RTC_I2C_WRITE(DS3231_REG_SECONDS); 
01E3:  CLRF   3C
01E4:  CALL   146
....................   RTC_I2C_START(); 
01E5:  BSF    03.5
01E6:  BSF    11.1
01E7:  BTFSC  11.1
01E8:  GOTO   1E7
....................   RTC_I2C_WRITE(DS3231_ADDRESS | 0x01); 
01E9:  MOVLW  D1
01EA:  BCF    03.5
01EB:  MOVWF  3C
01EC:  CALL   146
....................   c_time.seconds = RTC_I2C_READ(1); 
01ED:  MOVLW  01
01EE:  MOVWF  77
01EF:  CALL   156
01F0:  MOVF   78,W
01F1:  MOVWF  21
....................   c_time.minutes = RTC_I2C_READ(1); 
01F2:  MOVLW  01
01F3:  MOVWF  77
01F4:  CALL   156
01F5:  MOVF   78,W
01F6:  MOVWF  22
....................   c_time.hours   = RTC_I2C_READ(1); 
01F7:  MOVLW  01
01F8:  MOVWF  77
01F9:  CALL   156
01FA:  MOVF   78,W
01FB:  MOVWF  23
....................   c_time.dow   = RTC_I2C_READ(1); 
01FC:  MOVLW  01
01FD:  MOVWF  77
01FE:  CALL   156
01FF:  MOVF   78,W
0200:  MOVWF  24
....................   c_time.day   = RTC_I2C_READ(1); 
0201:  MOVLW  01
0202:  MOVWF  77
0203:  CALL   156
0204:  MOVF   78,W
0205:  MOVWF  25
....................   c_time.month = RTC_I2C_READ(1); 
0206:  MOVLW  01
0207:  MOVWF  77
0208:  CALL   156
0209:  MOVF   78,W
020A:  MOVWF  26
....................   c_time.year  = RTC_I2C_READ(0); 
020B:  CLRF   77
020C:  CALL   156
020D:  MOVF   78,W
020E:  MOVWF  27
....................   RTC_I2C_STOP(); 
020F:  BSF    03.5
0210:  BSF    11.2
0211:  BTFSC  11.2
0212:  GOTO   211
....................  
....................   // convert BCD to decimal 
....................   c_time.seconds = bcd_to_decimal(c_time.seconds); 
0213:  BCF    03.5
0214:  MOVF   21,W
0215:  MOVWF  38
0216:  CALL   1A6
0217:  MOVF   78,W
0218:  MOVWF  21
....................   c_time.minutes = bcd_to_decimal(c_time.minutes); 
0219:  MOVF   22,W
021A:  MOVWF  38
021B:  CALL   1A6
021C:  MOVF   78,W
021D:  MOVWF  22
....................   c_time.hours   = bcd_to_decimal(c_time.hours); 
021E:  MOVF   23,W
021F:  MOVWF  38
0220:  CALL   1A6
0221:  MOVF   78,W
0222:  MOVWF  23
....................   c_time.day     = bcd_to_decimal(c_time.day); 
0223:  MOVF   25,W
0224:  MOVWF  38
0225:  CALL   1A6
0226:  MOVF   78,W
0227:  MOVWF  25
....................   c_time.month   = bcd_to_decimal(c_time.month); 
0228:  MOVF   26,W
0229:  MOVWF  38
022A:  CALL   1A6
022B:  MOVF   78,W
022C:  MOVWF  26
....................   c_time.year    = bcd_to_decimal(c_time.year); 
022D:  MOVF   27,W
022E:  MOVWF  38
022F:  CALL   1A6
0230:  MOVF   78,W
0231:  MOVWF  27
....................   // end conversion 
....................  
....................   return &c_time; 
0232:  MOVLW  21
0233:  MOVWF  78
0234:  MOVLW  00
0235:  MOVWF  79
0236:  BCF    0A.3
0237:  BCF    0A.4
0238:  GOTO   313 (RETURN)
.................... } 
....................  
.................... // sets alarm1 details 
.................... void Alarm1_Set(RTC_Time *time_t, al1 _config) 
.................... { 
....................   // convert decimal to BCD 
....................   time_t->day     = decimal_to_bcd(time_t->day); 
....................   time_t->hours   = decimal_to_bcd(time_t->hours); 
....................   time_t->minutes = decimal_to_bcd(time_t->minutes); 
....................   time_t->seconds = decimal_to_bcd(time_t->seconds); 
....................   // end conversion 
....................  
....................   // write data to the RTC chip 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS3231_ADDRESS); 
....................   RTC_I2C_WRITE(DS3231_REG_AL1_SEC); 
....................   RTC_I2C_WRITE( (time_t->seconds) | (bit_test(_config, 0) << 7) ); 
....................   RTC_I2C_WRITE( (time_t->minutes) | (bit_test(_config, 1) << 7) ); 
....................   RTC_I2C_WRITE( (time_t->hours) | (bit_test(_config, 2) << 7) ); 
....................   if ( bit_test(_config, 4) ) 
....................     RTC_I2C_WRITE( (time_t->dow) | 0x40 | (bit_test(_config, 3) << 7) ); 
....................   else 
....................     RTC_I2C_WRITE( (time_t->day) | (bit_test(_config, 3) << 7) ); 
....................   RTC_I2C_STOP(); 
.................... } 
....................  
.................... // reads alarm1 details 
.................... RTC_Time *Alarm1_Get() 
.................... { 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS3231_ADDRESS); 
....................   RTC_I2C_WRITE(DS3231_REG_AL1_SEC); 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS3231_ADDRESS | 0x01); 
....................   c_alarm1.seconds = RTC_I2C_READ(1) & 0x7F; 
....................   c_alarm1.minutes = RTC_I2C_READ(1) & 0x7F; 
....................   c_alarm1.hours   = RTC_I2C_READ(1) & 0x3F; 
....................   c_alarm1.dow = c_alarm1.day = RTC_I2C_READ(0) & 0x3F; 
....................   RTC_I2C_STOP(); 
....................  
....................   // convert BCD to decimal 
....................   c_alarm1.seconds = bcd_to_decimal(c_alarm1.seconds); 
....................   c_alarm1.minutes = bcd_to_decimal(c_alarm1.minutes); 
....................   c_alarm1.hours   = bcd_to_decimal(c_alarm1.hours); 
....................   c_alarm1.day     = bcd_to_decimal(c_alarm1.day); 
....................   // end conversion 
....................  
....................   return &c_alarm1; 
.................... } 
....................  
.................... // enables alarm1 
.................... void Alarm1_Enable() 
.................... { 
....................   uint8_t ctrl_reg = RTC_Read_Reg(DS3231_REG_CONTROL); 
....................   ctrl_reg |= 0x01; 
....................   RTC_Write_Reg(DS3231_REG_CONTROL, ctrl_reg); 
.................... } 
....................  
.................... // disables alarm1 
.................... void Alarm1_Disable() 
.................... { 
....................   uint8_t ctrl_reg = RTC_Read_Reg(DS3231_REG_CONTROL); 
....................   ctrl_reg &= 0xFE; 
....................   RTC_Write_Reg(DS3231_REG_CONTROL, ctrl_reg); 
.................... } 
....................  
.................... // checks if alarm1 occurred, returns 1 if yes and 0 if no 
.................... int1 Alarm1_IF_Check() 
.................... { 
....................   uint8_t stat_reg = RTC_Read_Reg(DS3231_REG_STATUS); 
....................   return bit_test(stat_reg, 0); 
.................... } 
....................  
.................... // resets alarm1 flag bit 
.................... void Alarm1_IF_Reset() 
.................... { 
....................   uint8_t stat_reg = RTC_Read_Reg(DS3231_REG_STATUS); 
....................   stat_reg &= 0xFE; 
....................   RTC_Write_Reg(DS3231_REG_STATUS, stat_reg); 
.................... } 
....................  
.................... // returns TRUE (1) if alarm1 is enabled and FALSE (0) if disabled 
.................... int1 Alarm1_Status() 
.................... { 
....................   uint8_t ctrl_reg = RTC_Read_Reg(DS3231_REG_CONTROL); 
....................   if(ctrl_reg & 0x01) 
....................     return 1; 
....................   else 
....................     return 0; 
.................... } 
....................  
.................... // sets alarm2 details 
.................... void Alarm2_Set(RTC_Time *time_t, al2 _config) 
.................... { 
....................   // convert decimal to BCD 
....................   time_t->day     = decimal_to_bcd(time_t->day); 
....................   time_t->hours   = decimal_to_bcd(time_t->hours); 
....................   time_t->minutes = decimal_to_bcd(time_t->minutes); 
....................   // end conversion 
....................  
....................   // write data to the RTC chip 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS3231_ADDRESS); 
....................   RTC_I2C_WRITE(DS3231_REG_AL2_MIN); 
....................   RTC_I2C_WRITE( (time_t->minutes) | (bit_test(_config, 1) << 7) ); 
....................   RTC_I2C_WRITE( (time_t->hours) | (bit_test(_config, 2) << 7) ); 
....................   if ( bit_test(_config, 4) ) 
....................     RTC_I2C_WRITE( (time_t->dow) | 0x40 | (bit_test(_config, 3) << 7) ); 
....................   else 
....................     RTC_I2C_WRITE( (time_t->day) | (bit_test(_config, 3) << 7) ); 
....................   RTC_I2C_STOP(); 
.................... } 
....................  
.................... // reads alarm2 details 
.................... RTC_Time *Alarm2_Get() 
.................... { 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS3231_ADDRESS); 
....................   RTC_I2C_WRITE(DS3231_REG_AL2_MIN); 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS3231_ADDRESS | 0x01); 
....................   c_alarm2.minutes = RTC_I2C_READ(1) & 0x7F; 
....................   c_alarm2.hours   = RTC_I2C_READ(1) & 0x3F; 
....................   c_alarm2.dow = c_alarm2.day = RTC_I2C_READ(0) & 0x3F; 
....................   RTC_I2C_STOP(); 
....................  
....................   // convert BCD to decimal 
....................   c_alarm2.minutes = bcd_to_decimal(c_alarm2.minutes); 
....................   c_alarm2.hours   = bcd_to_decimal(c_alarm2.hours); 
....................   c_alarm2.day     = bcd_to_decimal(c_alarm2.day); 
....................   // end conversion 
....................  
....................   return &c_alarm2; 
.................... } 
....................  
.................... // enables alarm2 
.................... void Alarm2_Enable() 
.................... { 
....................   uint8_t ctrl_reg = RTC_Read_Reg(DS3231_REG_CONTROL); 
....................   ctrl_reg |= 0x02; 
....................   RTC_Write_Reg(DS3231_REG_CONTROL, ctrl_reg); 
.................... } 
....................  
.................... //disables alarm2 
.................... void Alarm2_Disable() 
.................... { 
....................   uint8_t ctrl_reg = RTC_Read_Reg(DS3231_REG_CONTROL); 
....................   ctrl_reg &= 0xFD; 
....................   RTC_Write_Reg(DS3231_REG_CONTROL, ctrl_reg); 
.................... } 
....................  
.................... // checks if alarm2 occurred, returns 1 if yes and 0 if no 
.................... int1 Alarm2_IF_Check() 
.................... { 
....................   uint8_t stat_reg = RTC_Read_Reg(DS3231_REG_STATUS); 
....................   return bit_test(stat_reg, 1); 
.................... } 
....................  
.................... // resets alarm2 flag bit 
.................... void Alarm2_IF_Reset() 
.................... { 
....................   uint8_t stat_reg = RTC_Read_Reg(DS3231_REG_STATUS); 
....................   stat_reg &= 0xFD; 
....................   RTC_Write_Reg(DS3231_REG_STATUS, stat_reg); 
.................... } 
....................  
.................... // returns TRUE (1) if alarm2 is enabled and FALSE (0) if disabled 
.................... int1 Alarm2_Status() 
.................... { 
....................   uint8_t ctrl_reg = RTC_Read_Reg(DS3231_REG_CONTROL); 
....................   if(ctrl_reg & 0x02) 
....................     return 1; 
....................   else 
....................     return 0; 
.................... } 
....................  
.................... // writes 'reg_value' to register of address 'reg_address' 
.................... void RTC_Write_Reg(uint8_t reg_address, uint8_t reg_value) 
.................... { 
....................   RTC_I2C_START(); 
*
0190:  BSF    03.5
0191:  BSF    11.0
0192:  BTFSC  11.0
0193:  GOTO   192
....................   RTC_I2C_WRITE(DS3231_ADDRESS); 
0194:  MOVLW  D0
0195:  BCF    03.5
0196:  MOVWF  3C
0197:  CALL   146
....................   RTC_I2C_WRITE(reg_address); 
0198:  MOVF   3A,W
0199:  MOVWF  3C
019A:  CALL   146
....................   RTC_I2C_WRITE(reg_value); 
019B:  MOVF   3B,W
019C:  MOVWF  3C
019D:  CALL   146
....................   RTC_I2C_STOP(); 
019E:  BSF    03.5
019F:  BSF    11.2
01A0:  BTFSC  11.2
01A1:  GOTO   1A0
.................... } 
....................  
.................... // returns the value stored in register of address 'reg_address' 
.................... uint8_t RTC_Read_Reg(uint8_t reg_address) 
.................... { 
....................   uint8_t reg_data; 
....................  
....................   RTC_I2C_START(); 
*
0168:  BSF    03.5
0169:  BSF    11.0
016A:  BTFSC  11.0
016B:  GOTO   16A
....................   RTC_I2C_WRITE(DS3231_ADDRESS); 
016C:  MOVLW  D0
016D:  BCF    03.5
016E:  MOVWF  3C
016F:  CALL   146
....................   RTC_I2C_WRITE(reg_address); 
0170:  MOVF   3A,W
0171:  MOVWF  3C
0172:  CALL   146
....................   RTC_I2C_START(); 
0173:  BSF    03.5
0174:  BSF    11.1
0175:  BTFSC  11.1
0176:  GOTO   175
....................   RTC_I2C_WRITE(DS3231_ADDRESS | 0x01); 
0177:  MOVLW  D1
0178:  BCF    03.5
0179:  MOVWF  3C
017A:  CALL   146
....................   reg_data = RTC_I2C_READ(0); 
017B:  CLRF   77
017C:  CALL   156
017D:  MOVF   78,W
017E:  MOVWF  3B
....................   RTC_I2C_STOP(); 
017F:  BSF    03.5
0180:  BSF    11.2
0181:  BTFSC  11.2
0182:  GOTO   181
....................  
....................   return reg_data; 
0183:  BCF    03.5
0184:  MOVF   3B,W
0185:  MOVWF  78
.................... } 
....................  
.................... // sets INT/SQW pin configuration 
.................... void IntSqw_Set(INT_SQW _config) 
*
0166:  MOVLW  0E
0167:  MOVWF  3A
*
0186:  MOVF   78,W
0187:  MOVWF  39
.................... { 
....................   uint8_t ctrl_reg = RTC_Read_Reg(DS3231_REG_CONTROL); 
....................   ctrl_reg &= 0xA3; 
0188:  MOVLW  A3
0189:  ANDWF  39,F
....................   ctrl_reg |= _config; 
018A:  MOVF   38,W
018B:  IORWF  39,F
....................   RTC_Write_Reg(DS3231_REG_CONTROL, ctrl_reg); 
018C:  MOVLW  0E
018D:  MOVWF  3A
018E:  MOVF   39,W
018F:  MOVWF  3B
*
01A2:  BCF    03.5
01A3:  BCF    0A.3
01A4:  BCF    0A.4
01A5:  GOTO   312 (RETURN)
.................... } 
....................  
.................... // enables 32kHz (pin 32kHz) 
.................... void Enable_32kHZ() 
.................... { 
....................   uint8_t stat_reg = RTC_Read_Reg(DS3231_REG_STATUS); 
....................   stat_reg |= 0x08; 
....................   RTC_Write_Reg(DS3231_REG_STATUS, stat_reg); 
.................... } 
....................  
.................... // disables 32kHz (pin 32kHz) 
.................... void Disable_32kHZ() 
.................... { 
....................   uint8_t stat_reg = RTC_Read_Reg(DS3231_REG_STATUS); 
....................   stat_reg &= 0xF7; 
....................   RTC_Write_Reg(DS3231_REG_STATUS, stat_reg); 
.................... } 
....................  
.................... // starts RTC oscillator 
.................... void OSC_Start() 
.................... { 
....................   uint8_t ctrl_reg = RTC_Read_Reg(DS3231_REG_CONTROL); 
....................   ctrl_reg &= 0x7F; 
....................   RTC_Write_Reg(DS3231_REG_CONTROL, ctrl_reg); 
.................... } 
....................  
.................... // stops RTC oscillator 
.................... void OSC_Stop() 
.................... { 
....................   uint8_t ctrl_reg = RTC_Read_Reg(DS3231_REG_CONTROL); 
....................   ctrl_reg |= 0x80; 
....................   RTC_Write_Reg(DS3231_REG_CONTROL, ctrl_reg); 
.................... } 
....................  
.................... // returns chip temperature 
.................... // Temperature is stored in hundredths C (output value of "3125" equals 31.25 °C). 
.................... int16_t Get_Temperature() 
.................... { 
....................   uint8_t t_msb, t_lsb; 
....................   uint16_t c_temp; 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS3231_ADDRESS); 
....................   RTC_I2C_WRITE(DS3231_REG_TEMP_MSB); 
....................   RTC_I2C_START(); 
....................   RTC_I2C_WRITE(DS3231_ADDRESS | 0x01); 
....................   t_msb = RTC_I2C_READ(1); 
....................   t_lsb = RTC_I2C_READ(0); 
....................   RTC_I2C_STOP(); 
....................  
....................   c_temp = (uint16_t)t_msb << 2 | t_lsb >> 6; 
....................  
....................   if(t_msb & 0x80) 
....................     c_temp |= 0xFC00; 
....................  
....................   return c_temp * 25; 
.................... } 
....................  
....................  
.................... RTC_Time *myTime; 
....................  
.................... void main() 
*
02DC:  MOVF   03,W
02DD:  ANDLW  1F
02DE:  MOVWF  03
02DF:  MOVLW  FF
02E0:  MOVWF  20
02E1:  BSF    20.3
02E2:  MOVF   20,W
02E3:  BSF    03.5
02E4:  MOVWF  07
02E5:  BCF    03.5
02E6:  BSF    20.4
02E7:  MOVF   20,W
02E8:  BSF    03.5
02E9:  MOVWF  07
02EA:  MOVLW  31
02EB:  MOVWF  13
02EC:  MOVLW  28
02ED:  BCF    03.5
02EE:  MOVWF  14
02EF:  BSF    03.5
02F0:  BSF    14.7
02F1:  BCF    14.6
02F2:  BSF    1F.0
02F3:  BSF    1F.1
02F4:  BSF    1F.2
02F5:  BCF    1F.3
02F6:  MOVLW  07
02F7:  MOVWF  1C
02F8:  BCF    03.7
.................... {   
....................    delay_ms(100); 
02F9:  MOVLW  64
02FA:  BCF    03.5
02FB:  MOVWF  40
02FC:  CALL   01E
....................    lcd_ini(); 
02FD:  GOTO   07A
....................    delay_ms(100); 
02FE:  MOVLW  64
02FF:  MOVWF  40
0300:  CALL   01E
....................    printf(lcd_escreve, "\fIniciando..."); 
0301:  MOVLW  0C
0302:  BSF    03.6
0303:  MOVWF  0D
0304:  MOVLW  00
0305:  MOVWF  0F
0306:  BCF    03.6
0307:  GOTO   0EE
....................    delay_ms(1000);  // wait a second 
0308:  MOVLW  04
0309:  MOVWF  38
030A:  MOVLW  FA
030B:  MOVWF  40
030C:  CALL   01E
030D:  DECFSZ 38,F
030E:  GOTO   30A
....................    /* 
....................    myTime = RTC_Get(); 
....................    printf(lcd_escreve,"\fvai comecar"); 
....................    printf(lcd_escreve, "\fTIME: %02u:%02u:%02u\n", myTime->hours, myTime->minutes, myTime->seconds); 
....................    printf(lcd_escreve,"atualizando..."); 
....................    delay_ms(3000); 
....................     
....................    //set RTC time to 21:08:47 (hh:mm:ss) and date to 03-01-19 (dd-mm-yy) 
....................    myTime->hours = 3; 
....................    printf(lcd_escreve,"\fhours"); 
....................    myTime->minutes = 47; 
....................    printf(lcd_escreve,"\fminutes"); 
....................    myTime->seconds = 47; 
....................    myTime->dow     = TUESDAY; 
....................    myTime->day     = 11; 
....................    myTime->month   = AUGUST; 
....................    myTime->year    = 22; 
....................    // write time and date to the RTC chip 
....................    RTC_Set(myTime); 
....................  
....................    //printf(lcd_escreve,"\fPassou"); 
....................    delay_ms(100); 
....................    printf(lcd_escreve, "\fTIME: %02u:%02u:%02u", myTime->hours, myTime->minutes, myTime->seconds); 
....................    */ 
....................    IntSqw_Set(OUT_1Hz); 
030F:  MOVLW  40
0310:  MOVWF  38
0311:  GOTO   166
....................    while(TRUE) 
....................    { 
....................    myTime = RTC_Get(); 
0312:  GOTO   1DB
0313:  MOVF   79,W
0314:  MOVWF  37
0315:  MOVF   78,W
0316:  MOVWF  36
....................    printf(lcd_escreve, "\fTIME: %02u:%02u:%02u", myTime->hours, myTime->minutes, myTime->seconds); 
0317:  MOVLW  02
0318:  ADDWF  36,W
0319:  MOVWF  04
031A:  BCF    03.7
031B:  BTFSC  37.0
031C:  BSF    03.7
031D:  MOVF   00,W
031E:  MOVWF  38
031F:  MOVLW  01
0320:  ADDWF  36,W
0321:  MOVWF  04
0322:  BCF    03.7
0323:  BTFSC  37.0
0324:  BSF    03.7
0325:  MOVF   00,W
0326:  MOVWF  39
0327:  MOVF   36,W
0328:  MOVWF  04
0329:  BCF    03.7
032A:  BTFSC  37.0
032B:  BSF    03.7
032C:  MOVF   00,W
032D:  MOVWF  3A
032E:  MOVLW  13
032F:  BSF    03.6
0330:  MOVWF  0D
0331:  MOVLW  00
0332:  MOVWF  0F
0333:  BCF    03.0
0334:  MOVLW  07
0335:  BCF    03.6
0336:  MOVWF  3B
0337:  GOTO   239
0338:  MOVF   38,W
0339:  MOVWF  3B
033A:  MOVLW  01
033B:  MOVWF  3C
033C:  CALL   2A7
033D:  MOVLW  3A
033E:  MOVWF  3F
033F:  CALL   0B7
0340:  MOVF   39,W
0341:  MOVWF  3B
0342:  MOVLW  01
0343:  MOVWF  3C
0344:  CALL   2A7
0345:  MOVLW  3A
0346:  MOVWF  3F
0347:  CALL   0B7
0348:  MOVF   3A,W
0349:  MOVWF  3B
034A:  MOVLW  01
034B:  MOVWF  3C
034C:  CALL   2A7
....................    delay_ms(300); 
034D:  MOVLW  02
034E:  MOVWF  38
034F:  MOVLW  96
0350:  MOVWF  40
0351:  CALL   01E
0352:  DECFSZ 38,F
0353:  GOTO   34F
0354:  GOTO   312
....................    } 
.................... } 
0355:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
