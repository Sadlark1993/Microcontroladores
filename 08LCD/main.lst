CCS PCM C Compiler, Version 5.015, 5967               09-out-22 12:48

               Filename:   C:\Users\Sadla\OneDrive\Documentos\MEGAsync\doc\Facul\Microcontroladores\Projetos\08LCD\main.lst

               ROM used:   500 words (6%)
                           Largest free fragment is 2048
               RAM used:   7 (2%) at main() level
                           19 (5%) worst case
               Stack used: 4 locations
               Stack size: 8

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   19B
0003:  NOP
.................... //#include <main.h> 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  28
0009:  RETLW  0F
000A:  RETLW  01
000B:  RETLW  06
000C:  DATA 49,23
000D:  DATA 4D,2A
000E:  DATA 20,19
000F:  DATA 30,19
0010:  DATA 32,10
0011:  DATA 0D,05
0012:  DATA 00,00
0013:  DATA 49,23
0014:  DATA 4D,2A
0015:  DATA 20,19
0016:  DATA 30,19
0017:  DATA 32,10
0018:  DATA A5,31
0019:  DATA 00,00
*
00EA:  MOVF   0B,W
00EB:  MOVWF  22
00EC:  BCF    0B.7
00ED:  BSF    03.5
00EE:  BSF    03.6
00EF:  BSF    0C.7
00F0:  BSF    0C.0
00F1:  NOP
00F2:  NOP
00F3:  BCF    03.5
00F4:  BCF    03.6
00F5:  BTFSC  22.7
00F6:  BSF    0B.7
00F7:  BSF    03.6
00F8:  MOVF   0C,W
00F9:  ANDLW  7F
00FA:  BTFSC  03.2
00FB:  GOTO   13E
00FC:  BCF    03.6
00FD:  MOVWF  22
00FE:  BSF    03.6
00FF:  MOVF   0D,W
0100:  BCF    03.6
0101:  MOVWF  23
0102:  BSF    03.6
0103:  MOVF   0F,W
0104:  BCF    03.6
0105:  MOVWF  24
0106:  MOVF   22,W
0107:  MOVWF  26
0108:  CALL   0B3
0109:  MOVF   23,W
010A:  BSF    03.6
010B:  MOVWF  0D
010C:  BCF    03.6
010D:  MOVF   24,W
010E:  BSF    03.6
010F:  MOVWF  0F
0110:  BCF    03.6
0111:  MOVF   0B,W
0112:  MOVWF  25
0113:  BCF    0B.7
0114:  BSF    03.5
0115:  BSF    03.6
0116:  BSF    0C.7
0117:  BSF    0C.0
0118:  NOP
0119:  NOP
011A:  BCF    03.5
011B:  BCF    03.6
011C:  BTFSC  25.7
011D:  BSF    0B.7
011E:  BSF    03.6
011F:  RLF    0C,W
0120:  RLF    0E,W
0121:  ANDLW  7F
0122:  BTFSC  03.2
0123:  GOTO   13E
0124:  BCF    03.6
0125:  MOVWF  22
0126:  BSF    03.6
0127:  MOVF   0D,W
0128:  BCF    03.6
0129:  MOVWF  23
012A:  BSF    03.6
012B:  MOVF   0F,W
012C:  BCF    03.6
012D:  MOVWF  24
012E:  MOVF   22,W
012F:  MOVWF  26
0130:  CALL   0B3
0131:  MOVF   23,W
0132:  BSF    03.6
0133:  MOVWF  0D
0134:  BCF    03.6
0135:  MOVF   24,W
0136:  BSF    03.6
0137:  MOVWF  0F
0138:  INCF   0D,F
0139:  BTFSC  03.2
013A:  INCF   0F,F
013B:  BCF    03.6
013C:  GOTO   0EA
013D:  BSF    03.6
013E:  BCF    03.6
013F:  BCF    0A.3
0140:  BCF    0A.4
0141:  GOTO   1BA (RETURN)
0142:  MOVF   0B,W
0143:  MOVWF  23
0144:  BCF    0B.7
0145:  BSF    03.5
0146:  BSF    03.6
0147:  BSF    0C.7
0148:  BSF    0C.0
0149:  NOP
014A:  NOP
014B:  BCF    03.5
014C:  BCF    03.6
014D:  BTFSC  23.7
014E:  BSF    0B.7
014F:  BTFSC  03.0
0150:  GOTO   179
0151:  BSF    03.6
0152:  MOVF   0C,W
0153:  ANDLW  7F
0154:  BCF    03.6
0155:  MOVWF  23
0156:  BSF    03.6
0157:  MOVF   0D,W
0158:  BCF    03.6
0159:  MOVWF  24
015A:  BSF    03.6
015B:  MOVF   0F,W
015C:  BCF    03.6
015D:  MOVWF  25
015E:  MOVF   23,W
015F:  MOVWF  26
0160:  CALL   0B3
0161:  MOVF   24,W
0162:  BSF    03.6
0163:  MOVWF  0D
0164:  BCF    03.6
0165:  MOVF   25,W
0166:  BSF    03.6
0167:  MOVWF  0F
0168:  BCF    03.6
0169:  MOVF   0B,W
016A:  MOVWF  26
016B:  BCF    0B.7
016C:  BSF    03.5
016D:  BSF    03.6
016E:  BSF    0C.7
016F:  BSF    0C.0
0170:  NOP
0171:  NOP
0172:  BCF    03.5
0173:  BCF    03.6
0174:  BTFSC  26.7
0175:  BSF    0B.7
0176:  DECFSZ 22,F
0177:  GOTO   179
0178:  GOTO   198
0179:  BSF    03.6
017A:  RLF    0C,W
017B:  RLF    0E,W
017C:  ANDLW  7F
017D:  BCF    03.6
017E:  MOVWF  23
017F:  BSF    03.6
0180:  MOVF   0D,W
0181:  BCF    03.6
0182:  MOVWF  24
0183:  BSF    03.6
0184:  MOVF   0F,W
0185:  BCF    03.6
0186:  MOVWF  25
0187:  MOVF   23,W
0188:  MOVWF  26
0189:  CALL   0B3
018A:  MOVF   24,W
018B:  BSF    03.6
018C:  MOVWF  0D
018D:  BCF    03.6
018E:  MOVF   25,W
018F:  BSF    03.6
0190:  MOVWF  0F
0191:  INCF   0D,F
0192:  BTFSC  03.2
0193:  INCF   0F,F
0194:  BCF    03.0
0195:  BCF    03.6
0196:  DECFSZ 22,F
0197:  GOTO   142
0198:  BCF    0A.3
0199:  BCF    0A.4
019A:  GOTO   1DB (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20000000) 
*
001A:  MOVLW  27
001B:  MOVWF  04
001C:  BCF    03.7
001D:  MOVF   00,W
001E:  BTFSC  03.2
001F:  GOTO   02D
0020:  MOVLW  06
0021:  MOVWF  78
0022:  CLRF   77
0023:  DECFSZ 77,F
0024:  GOTO   023
0025:  DECFSZ 78,F
0026:  GOTO   022
0027:  MOVLW  7B
0028:  MOVWF  77
0029:  DECFSZ 77,F
002A:  GOTO   029
002B:  DECFSZ 00,F
002C:  GOTO   020
002D:  RETURN
....................  
.................... #define lcd_enable       pin_e1      // pino enable do LCD 
.................... #define lcd_rs         pin_e2      // pino rs do LCD 
.................... //#define lcd_rw      pin_e2      // pino rw do LCD 
.................... #define lcd_d4         pin_d4      // pino de dados d4 do LCD 
.................... #define lcd_d5         pin_d5      // pino de dados d5 do LCD 
.................... #define lcd_d6         pin_d6      // pino de dados d6 do LCD 
.................... #define lcd_d7         pin_d7      // pino de dados d7 do LCD 
....................  
.................... #define LED pin_d1 
....................  
.................... #include <mod_lcd.c> 
.................... /************************************************************************/ 
.................... /*  MOD_LCD.C - Biblioteca de manipulação de módulo LCD                 */ 
.................... /*                                                                      */ 
.................... /*  Autor: Fábio Pereira                                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // As definições a seguir são utilizadas para acesso aos pinos do display 
.................... // caso o pino RW não seja utilizado, comente a definição lcd_rw 
.................... #ifndef lcd_enable 
.................... 	#define lcd_enable 		pin_e1		// pino enable do LCD 
.................... 	#define lcd_rs			pin_e0		// pino rs do LCD 
.................... 	//#define lcd_rw		pin_e2		// pino rw do LCD 
.................... 	#define lcd_d4			pin_d4		// pino de dados d4 do LCD 
.................... 	#define lcd_d5			pin_d5		// pino de dados d5 do LCD 
.................... 	#define lcd_d6			pin_d6		// pino de dados d6 do LCD 
.................... 	#define lcd_d7			pin_d7		// pino de dados d7 do LCD 
.................... #endif 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endereço da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seqüência de inicialização do módulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... byte lcd_le_byte() 
.................... // lê um byte do LCD (somente com pino RW) 
.................... { 
.................... 	byte dado; 
.................... 	// configura os pinos de dados como entradas 
.................... 	input(lcd_d4); 
.................... 	input(lcd_d5); 
.................... 	input(lcd_d6); 
.................... 	input(lcd_d7); 
.................... 	// se o pino rw for utilizado, coloca em 1 
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
....................    output_high(lcd_enable); // habilita display 
.................... 	dado = 0;	// zera a variável de leitura 
.................... 	// lê os quatro bits mais significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,7); 
.................... 	if (input(lcd_d6)) bit_set(dado,6); 
.................... 	if (input(lcd_d5)) bit_set(dado,5); 
.................... 	if (input(lcd_d4)) bit_set(dado,4); 
.................... 	// dá um pulso na linha enable 
.................... 	output_low(lcd_enable); 
.................... 	output_high(lcd_enable); 
.................... 	// lê os quatro bits menos significativos 
.................... 	if (input(lcd_d7)) bit_set(dado,3); 
.................... 	if (input(lcd_d6)) bit_set(dado,2); 
.................... 	if (input(lcd_d5)) bit_set(dado,1); 
.................... 	if (input(lcd_d4)) bit_set(dado,0); 
.................... 	output_low(lcd_enable);	// desabilita o display 
.................... 	return dado;	// retorna o byte lido 
.................... } 
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
.................... 	// coloca os quatro bits nas saidas 
.................... 	output_bit(lcd_d4,bit_test(dado,0)); 
002E:  BTFSC  2E.0
002F:  GOTO   032
0030:  BCF    08.4
0031:  GOTO   033
0032:  BSF    08.4
0033:  BSF    03.5
0034:  BCF    08.4
.................... 	output_bit(lcd_d5,bit_test(dado,1)); 
0035:  BCF    03.5
0036:  BTFSC  2E.1
0037:  GOTO   03A
0038:  BCF    08.5
0039:  GOTO   03B
003A:  BSF    08.5
003B:  BSF    03.5
003C:  BCF    08.5
.................... 	output_bit(lcd_d6,bit_test(dado,2)); 
003D:  BCF    03.5
003E:  BTFSC  2E.2
003F:  GOTO   042
0040:  BCF    08.6
0041:  GOTO   043
0042:  BSF    08.6
0043:  BSF    03.5
0044:  BCF    08.6
.................... 	output_bit(lcd_d7,bit_test(dado,3)); 
0045:  BCF    03.5
0046:  BTFSC  2E.3
0047:  GOTO   04A
0048:  BCF    08.7
0049:  GOTO   04B
004A:  BSF    08.7
004B:  BSF    03.5
004C:  BCF    08.7
.................... 	// dá um pulso na linha enable 
.................... 	output_high(lcd_enable); 
004D:  BCF    09.1
004E:  BCF    03.5
004F:  BSF    09.1
.................... 	output_low(lcd_enable); 
0050:  BSF    03.5
0051:  BCF    09.1
0052:  BCF    03.5
0053:  BCF    09.1
0054:  RETURN
.................... } 
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
.................... 	// coloca a linha rs em 0 
.................... 	output_low(lcd_rs); 
0055:  BSF    03.5
0056:  BCF    09.2
0057:  BCF    03.5
0058:  BCF    09.2
.................... 	// aguarda o display ficar desocupado 
.................... 	//while ( bit_test(lcd_le_byte(),7) ) ; 
.................... 	// configura a linha rs dependendo do modo selecionado 
.................... 	output_bit(lcd_rs,endereco); 
0059:  MOVF   2B,F
005A:  BTFSS  03.2
005B:  GOTO   05E
005C:  BCF    09.2
005D:  GOTO   05F
005E:  BSF    09.2
005F:  BSF    03.5
0060:  BCF    09.2
.................... 	delay_us(100);	// aguarda 100 us 
0061:  MOVLW  A6
0062:  MOVWF  77
0063:  DECFSZ 77,F
0064:  GOTO   063
0065:  NOP
.................... 	// caso a linha rw esteja definida, coloca em 0 
.................... 	#ifdef lcd_rw 
.................... 		output_low(lcd_rw); 
.................... 	#endif 
.................... 	// desativa linha enable 
.................... 	output_low(lcd_enable); 
0066:  BCF    09.1
0067:  BCF    03.5
0068:  BCF    09.1
.................... 	// envia a primeira parte do byte 
.................... 	lcd_envia_nibble(dado >> 4); 
0069:  SWAPF  2C,W
006A:  MOVWF  2D
006B:  MOVLW  0F
006C:  ANDWF  2D,F
006D:  MOVF   2D,W
006E:  MOVWF  2E
006F:  CALL   02E
.................... 	// envia a segunda parte do byte 
.................... 	lcd_envia_nibble(dado & 0x0f); 
0070:  MOVF   2C,W
0071:  ANDLW  0F
0072:  MOVWF  2D
0073:  MOVWF  2E
0074:  CALL   02E
0075:  RETURN
.................... } 
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicialização do display 
.................... { 
.................... 	byte conta; 
.................... 	output_low(lcd_d4); 
0076:  BSF    03.5
0077:  BCF    08.4
0078:  BCF    03.5
0079:  BCF    08.4
.................... 	output_low(lcd_d5); 
007A:  BSF    03.5
007B:  BCF    08.5
007C:  BCF    03.5
007D:  BCF    08.5
.................... 	output_low(lcd_d6); 
007E:  BSF    03.5
007F:  BCF    08.6
0080:  BCF    03.5
0081:  BCF    08.6
.................... 	output_low(lcd_d7); 
0082:  BSF    03.5
0083:  BCF    08.7
0084:  BCF    03.5
0085:  BCF    08.7
.................... 	output_low(lcd_rs); 
0086:  BSF    03.5
0087:  BCF    09.2
0088:  BCF    03.5
0089:  BCF    09.2
.................... 	#ifdef lcd_rw 
.................... 		output_high(lcd_rw); 
.................... 	#endif 
.................... 	output_low(lcd_enable); 
008A:  BSF    03.5
008B:  BCF    09.1
008C:  BCF    03.5
008D:  BCF    09.1
.................... 	delay_ms(15); 
008E:  MOVLW  0F
008F:  MOVWF  27
0090:  CALL   01A
.................... 	// envia uma seqüência de 3 vezes 0x03 
.................... 	// e depois 0x02 para configurar o módulo 
.................... 	// para modo de 4 bits 
.................... 	for(conta=1;conta<=3;++conta) 
0091:  MOVLW  01
0092:  MOVWF  22
0093:  MOVF   22,W
0094:  SUBLW  03
0095:  BTFSS  03.0
0096:  GOTO   09F
.................... 	{ 
.................... 		lcd_envia_nibble(3); 
0097:  MOVLW  03
0098:  MOVWF  2E
0099:  CALL   02E
.................... 		delay_ms(5); 
009A:  MOVLW  05
009B:  MOVWF  27
009C:  CALL   01A
009D:  INCF   22,F
009E:  GOTO   093
.................... 	} 
.................... 	lcd_envia_nibble(2); 
009F:  MOVLW  02
00A0:  MOVWF  2E
00A1:  CALL   02E
.................... 	// envia string de inicialização do display 
.................... 	for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
00A2:  CLRF   22
00A3:  MOVF   22,W
00A4:  SUBLW  03
00A5:  BTFSS  03.0
00A6:  GOTO   0B0
00A7:  MOVF   22,W
00A8:  CALL   004
00A9:  MOVWF  23
00AA:  CLRF   2B
00AB:  MOVF   23,W
00AC:  MOVWF  2C
00AD:  CALL   055
00AE:  INCF   22,F
00AF:  GOTO   0A3
00B0:  BCF    0A.3
00B1:  BCF    0A.4
00B2:  GOTO   1AB (RETURN)
.................... } 
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
*
00CD:  DECFSZ 28,W
00CE:  GOTO   0D0
00CF:  GOTO   0D3
....................    	endereco = lcd_seg_lin; 
00D0:  MOVLW  40
00D1:  MOVWF  29
00D2:  GOTO   0D4
....................    else 
....................    	endereco = 0; 
00D3:  CLRF   29
....................    endereco += x-1; 
00D4:  MOVLW  01
00D5:  SUBWF  27,W
00D6:  ADDWF  29,F
....................    lcd_envia_byte(0,0x80|endereco); 
00D7:  MOVF   29,W
00D8:  IORLW  80
00D9:  MOVWF  2A
00DA:  CLRF   2B
00DB:  MOVF   2A,W
00DC:  MOVWF  2C
00DD:  CALL   055
.................... } 
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
*
00B3:  MOVF   26,W
00B4:  XORLW  0C
00B5:  BTFSC  03.2
00B6:  GOTO   0C1
00B7:  XORLW  06
00B8:  BTFSC  03.2
00B9:  GOTO   0C9
00BA:  XORLW  07
00BB:  BTFSC  03.2
00BC:  GOTO   0C9
00BD:  XORLW  05
00BE:  BTFSC  03.2
00BF:  GOTO   0DF
00C0:  GOTO   0E4
.................... 	{ 
....................      case '\f' 	:	lcd_envia_byte(0,1); 
00C1:  CLRF   2B
00C2:  MOVLW  01
00C3:  MOVWF  2C
00C4:  CALL   055
.................... 	  			delay_ms(2); 
00C5:  MOVLW  02
00C6:  MOVWF  27
00C7:  CALL   01A
.................... 				break; 
00C8:  GOTO   0E9
....................      case '\n'	: 
.................... 	  case '\r' 	:	lcd_pos_xy(1,2); 
00C9:  MOVLW  01
00CA:  MOVWF  27
00CB:  MOVLW  02
00CC:  MOVWF  28
.................... 	  			break; 
*
00DE:  GOTO   0E9
....................      case '\b' 	:	lcd_envia_byte(0,0x10); 
00DF:  CLRF   2B
00E0:  MOVLW  10
00E1:  MOVWF  2C
00E2:  CALL   055
.................... 	  			break; 
00E3:  GOTO   0E9
....................      default	:	lcd_envia_byte(1,c); 
00E4:  MOVLW  01
00E5:  MOVWF  2B
00E6:  MOVF   26,W
00E7:  MOVWF  2C
00E8:  CALL   055
.................... 	  			break; 
....................    } 
00E9:  RETURN
.................... } 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
.................... 	char valor; 
.................... 	// seleciona a posição do caractere 
.................... 	lcd_pos_xy(x,y); 
.................... 	// ativa rs 
.................... 	output_high(lcd_rs); 
.................... 	// lê o caractere 
.................... 	valor = lcd_le_byte(); 
.................... 	// desativa rs 
.................... 	output_low(lcd_rs); 
.................... 	// retorna o valor do caractere 
.................... 	return valor; 
.................... } 
....................  
....................  
.................... void main() 
*
019B:  MOVF   03,W
019C:  ANDLW  1F
019D:  MOVWF  03
019E:  BSF    03.5
019F:  BSF    1F.0
01A0:  BSF    1F.1
01A1:  BSF    1F.2
01A2:  BCF    1F.3
01A3:  MOVLW  07
01A4:  MOVWF  1C
01A5:  BCF    03.7
.................... { 
....................    unsigned char c; 
....................    delay_ms(100); 
01A6:  MOVLW  64
01A7:  BCF    03.5
01A8:  MOVWF  27
01A9:  CALL   01A
....................    lcd_ini(); 
01AA:  GOTO   076
....................    delay_ms(100); 
01AB:  MOVLW  64
01AC:  MOVWF  27
01AD:  CALL   01A
....................    while(TRUE) 
....................    { 
....................       c = 'a'; 
01AE:  MOVLW  61
01AF:  MOVWF  21
....................       lcd_escreve('\f'); 
01B0:  MOVLW  0C
01B1:  MOVWF  26
01B2:  CALL   0B3
....................       printf(lcd_escreve, "IFMT 2022 \r\n"); 
01B3:  MOVLW  0C
01B4:  BSF    03.6
01B5:  MOVWF  0D
01B6:  MOVLW  00
01B7:  MOVWF  0F
01B8:  BCF    03.6
01B9:  GOTO   0EA
....................       printf(lcd_escreve, "LCD"); 
01BA:  MOVLW  4C
01BB:  MOVWF  26
01BC:  CALL   0B3
01BD:  MOVLW  43
01BE:  MOVWF  26
01BF:  CALL   0B3
01C0:  MOVLW  44
01C1:  MOVWF  26
01C2:  CALL   0B3
....................       output_high(LED); 
01C3:  BSF    03.5
01C4:  BCF    08.1
01C5:  BCF    03.5
01C6:  BSF    08.1
....................       delay_ms(3000);     
01C7:  MOVLW  0C
01C8:  MOVWF  22
01C9:  MOVLW  FA
01CA:  MOVWF  27
01CB:  CALL   01A
01CC:  DECFSZ 22,F
01CD:  GOTO   1C9
....................        
....................       lcd_escreve('\f'); 
01CE:  MOVLW  0C
01CF:  MOVWF  26
01D0:  CALL   0B3
....................       printf(lcd_escreve, "IFMT 2022 %c", c); 
01D1:  MOVLW  13
01D2:  BSF    03.6
01D3:  MOVWF  0D
01D4:  MOVLW  00
01D5:  MOVWF  0F
01D6:  BCF    03.0
01D7:  MOVLW  0A
01D8:  BCF    03.6
01D9:  MOVWF  22
01DA:  GOTO   142
01DB:  MOVF   21,W
01DC:  MOVWF  26
01DD:  CALL   0B3
....................       printf(lcd_escreve, "LCD"); 
01DE:  MOVLW  4C
01DF:  MOVWF  26
01E0:  CALL   0B3
01E1:  MOVLW  43
01E2:  MOVWF  26
01E3:  CALL   0B3
01E4:  MOVLW  44
01E5:  MOVWF  26
01E6:  CALL   0B3
....................       output_low(LED); 
01E7:  BSF    03.5
01E8:  BCF    08.1
01E9:  BCF    03.5
01EA:  BCF    08.1
....................       delay_ms(3000); 
01EB:  MOVLW  0C
01EC:  MOVWF  22
01ED:  MOVLW  FA
01EE:  MOVWF  27
01EF:  CALL   01A
01F0:  DECFSZ 22,F
01F1:  GOTO   1ED
01F2:  GOTO   1AE
....................  
....................    } 
.................... } 
01F3:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
